package view;

import com.sun.glass.events.KeyEvent;
import data.*;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

public class GUI extends javax.swing.JFrame {
    Maze maze;
    Cell[][] cells;
    boolean game = false;
    int result = 0, numOfMoves = 0;

    /**
     * Creates new form GUI
     */
    public GUI() {
        initComponents();
        drawing.grabFocus();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        fileChooser = new javax.swing.JFileChooser();
        placeChooser = new javax.swing.JFileChooser();
        drawing = new view.Drawing();
        jMenuBar = new javax.swing.JMenuBar();
        Start = new javax.swing.JMenu();
        CreateMaze = new javax.swing.JMenuItem();
        LoadFile = new javax.swing.JMenuItem();
        SaveFile = new javax.swing.JMenuItem();
        Exit = new javax.swing.JMenuItem();
        EditMode = new javax.swing.JMenu();
        Dot = new javax.swing.JMenuItem();
        Color = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        Edit = new javax.swing.JRadioButtonMenuItem();
        Play = new javax.swing.JRadioButtonMenuItem();
        Game = new javax.swing.JMenu();
        TakeAChallenge = new javax.swing.JMenuItem();

        fileChooser.setDialogTitle("Please choose a file");
        fileChooser.setFileFilter(new MyCustomFilter());

        placeChooser.setDialogTitle("Please choose the place for saving");
        placeChooser.setFileFilter(new MyCustomFilter());

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Maze");

        drawing.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                drawingMouseClicked(evt);
            }
        });
        drawing.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                drawingKeyReleased(evt);
            }
        });

        javax.swing.GroupLayout drawingLayout = new javax.swing.GroupLayout(drawing);
        drawing.setLayout(drawingLayout);
        drawingLayout.setHorizontalGroup(
            drawingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 380, Short.MAX_VALUE)
        );
        drawingLayout.setVerticalGroup(
            drawingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 257, Short.MAX_VALUE)
        );

        Start.setText("Start");

        CreateMaze.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        CreateMaze.setText("Create a Maze");
        CreateMaze.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CreateMazeActionPerformed(evt);
            }
        });
        Start.add(CreateMaze);

        LoadFile.setText("Load a Maze");
        LoadFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LoadFileActionPerformed(evt);
            }
        });
        Start.add(LoadFile);

        SaveFile.setText("Save a Maze");
        SaveFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SaveFileActionPerformed(evt);
            }
        });
        Start.add(SaveFile);

        Exit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE, 0));
        Exit.setText("Exit");
        Exit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExitActionPerformed(evt);
            }
        });
        Start.add(Exit);

        jMenuBar.add(Start);

        EditMode.setText("Edit Mode");

        Dot.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        Dot.setText("Create a Dot");
        Dot.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DotActionPerformed(evt);
            }
        });
        EditMode.add(Dot);

        Color.setText("Change the color");
        Color.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ColorActionPerformed(evt);
            }
        });
        EditMode.add(Color);
        EditMode.add(jSeparator1);

        buttonGroup1.add(Edit);
        Edit.setText("Edit");
        EditMode.add(Edit);

        buttonGroup1.add(Play);
        Play.setSelected(true);
        Play.setText("Play");
        EditMode.add(Play);

        jMenuBar.add(EditMode);

        Game.setText("Game");

        TakeAChallenge.setText("Take a challenge");
        TakeAChallenge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TakeAChallengeActionPerformed(evt);
            }
        });
        Game.add(TakeAChallenge);

        jMenuBar.add(Game);

        setJMenuBar(jMenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(drawing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(drawing, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void CreateMazeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CreateMazeActionPerformed
        MazeInputs input = new MazeInputs(this, true);
        input.setVisible(true);  
        if (input.isEntered()) {
            maze = new Maze(input.getH(), input.getW());
            drawing.setMaze(maze);
            drawing.setEntered(false);
            game = false;
            this.repaint();
        }
    }//GEN-LAST:event_CreateMazeActionPerformed

    private void ExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_ExitActionPerformed

    private void DotActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DotActionPerformed
        if (maze != null) {
            DotInputs di = new DotInputs(this, true);
            di.showProperties(maze.numOfRows, maze.numOfColumns);
            if (di.isEntered()) {
                maze.addDots(di.getName(), di.getRow(), di.getColumn());
                this.repaint();
            }
        }
    }//GEN-LAST:event_DotActionPerformed

    private void drawingMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_drawingMouseClicked
        if (maze != null && Edit.isSelected()) {
            int x = evt.getX();
            int y = evt.getY();
            int row = y / drawing.getZoom();
            int column = x / drawing.getZoom();
            Direction d;
            Cell currentCell;
            int vertical = x % drawing.getZoom();
            int horizontal = y % drawing.getZoom();
            if (Math.abs(vertical - drawing.getZoom() / 2) > Math.abs(horizontal - drawing.getZoom() / 2)) {
                if (vertical < drawing.getZoom() / 2)
                    d = Direction.LEFT;
                else d = Direction.RIGHT;
            } else {
                if (horizontal < drawing.getZoom() / 2) 
                    d = Direction.UP;
                else d = Direction.DOWN;
            }
            currentCell = maze.getCells(row, column);
            if (currentCell.move[d.ordinal()] == false)
                 maze.removeWall(row, column, d);
            else maze.addWall(row, column, d);
            this.repaint();
        }
    }//GEN-LAST:event_drawingMouseClicked

    private void drawingKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_drawingKeyReleased
        if (Play.isSelected() && game == false) {
            if (maze != null && maze.getDots().size() > 0) {
                Dot dot = maze.getDots().get(0);
                switch(evt.getKeyCode()) {
                    case KeyEvent.VK_UP:
                        dot.goTo(Direction.UP);
                        break;
                    case KeyEvent.VK_RIGHT:
                        dot.goTo(Direction.RIGHT);
                        break;
                    case KeyEvent.VK_DOWN:
                        dot.goTo(Direction.DOWN);
                        break;
                    case KeyEvent.VK_LEFT:
                        dot.goTo(Direction.LEFT);
                        break;
                }
                if (maze.getDots().size() > 1) {
                    Dot dot1 = maze.getDots().get(1);
                    switch (evt.getKeyCode()) {
                         case KeyEvent.VK_W:
                            dot1.goTo(Direction.UP);
                            break;
                        case KeyEvent.VK_D:
                            dot1.goTo(Direction.RIGHT);
                            break;
                        case KeyEvent.VK_S:
                            dot1.goTo(Direction.DOWN);
                            break;
                        case KeyEvent.VK_A:
                            dot1.goTo(Direction.LEFT);
                            break;
                    }
                }
            this.repaint();
            }
        }
        if (Play.isSelected() && game == true) {
            Dot dot = maze.getDots().get(0);
            int x = dot.place.row, y  = dot.place.column;
                switch(evt.getKeyCode()) {
                        case KeyEvent.VK_UP:
                            dot.goTo(Direction.UP);
                            if (x != dot.place.row)
                                numOfMoves++;
                            break;
                        case KeyEvent.VK_RIGHT:
                            dot.goTo(Direction.RIGHT);
                            if (y != dot.place.column)
                                numOfMoves++;
                            break;
                        case KeyEvent.VK_DOWN:
                            dot.goTo(Direction.DOWN);
                            if (x != dot.place.row)
                                numOfMoves++;
                            break;
                        case KeyEvent.VK_LEFT:
                            dot.goTo(Direction.LEFT);
                            if (y != dot.place.column)
                                numOfMoves++;
                            break;
                }
            this.repaint();
            if (((dot.place.row == (maze.numOfRows - 1)) && (dot.place.column == (maze.numOfColumns - 1)))) {
                JOptionPane.showMessageDialog(this, "You have reached the final point in " + numOfMoves + " moves \n" + 
                        "The shortest way until final point is " + result + " moves", "Result", JOptionPane.INFORMATION_MESSAGE);
                drawing.setMaze(null);
                TakeAChallengeActionPerformed(null);
                numOfMoves = 0;
            }
        }
    }//GEN-LAST:event_drawingKeyReleased

    private void ColorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ColorActionPerformed
        ColorSettings cs = new ColorSettings(this, true);
        cs.setVisible(true);
        if (cs.isEntered()) {
            Color cl = cs.getDotColor();
            drawing.setDotColor(cl);
            Color cl1 = cs.getBorderColor();
            drawing.setBorderColor(cl1);
            Color cl2 = cs.getBackgroundColor();
            drawing.setBackgroundColor(cl2);
            this.repaint();
        }
    }//GEN-LAST:event_ColorActionPerformed
   
    private void TakeAChallengeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TakeAChallengeActionPerformed
        try {   
           Levels levels = new Levels(this, true);
           levels.setVisible(true);
           if (levels.isEntered()) {
               game = true;
               result = levels.getResult();
               int row = 0, column = 0, number;
               Direction d = Direction.UP;
               String[][] array = levels.getRemoves();
               maze = new Maze(levels.getH(), levels.getW());
               drawing.setMaze(maze);
               drawing.setEntered(true);
               maze.addDots("A", 0, 0);
               for (int i = 0; i < array.length; i++) {
                   for (int j = 0; j < array[i].length; j++) {
                       if (j == 0)
                           row = Integer.valueOf(array[i][j]);
                        if (j == 1)
                           column = Integer.valueOf(array[i][j]);
                        if ((j > 1) && (array[i][j] != null)) {
                            number = Integer.valueOf(array[i][j]);
                            switch(number) {
                                case 1:
                                    d = Direction.UP;
                                    break;
                                case 2:
                                    d = Direction.RIGHT;
                                    break;
                                case 3:
                                    d = Direction.DOWN;
                                    break;
                                case 4:
                                    d = Direction.LEFT;
                                    break;
                            }
                            maze.removeWall(row, column, d);
                        }
                   }
               }
            }
        } catch (Exception e) {      
        }
        this.repaint();
    }//GEN-LAST:event_TakeAChallengeActionPerformed

    private void LoadFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LoadFileActionPerformed
        int returnVal = fileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            try {
                BufferedReader reader = new BufferedReader(new FileReader(file));
                int h = 0, w = 0, count = 0;
                int row = 0, column = 0, number = 0;
                Direction d = Direction.UP;
                String line;
                String[] array;
                while ((line = reader.readLine()) != null) {
                    array = line.split("[ ,]");
                    for (int i = 0; i < array.length; i++) {
                        if (count == 0 && i == 0) {
                            h = Integer.valueOf(array[i]);
                        }
                        if (count == 0 && i == 1) {
                            w = Integer.valueOf(array[i]);
                        }
                        if (count == 0 && h != 0 && w != 0) {
                            maze = new Maze(h, w);
                            drawing.setMaze(maze);
                            count++;
                        }
                        if (count != 0) {
                            if (i == 0) {
                                row = Integer.valueOf(array[i]);
                            }
                            if (i == 1) {
                                column = Integer.valueOf(array[i]);
                            }
                            if (i > 1) {
                                number = Integer.valueOf(array[i]);
                                switch (number) {
                                    case 1:
                                        d = Direction.UP;
                                        break;
                                    case 2:
                                        d = Direction.RIGHT;
                                        break;
                                    case 3:
                                        d = Direction.DOWN;
                                        break;
                                    case 4:
                                        d = Direction.LEFT;
                                        break;
                                }
                                maze.removeWall(row, column, d);
                            }
                        }
                    }
                }
                reader.close();
            } catch (IOException ex) {
                System.out.println("Problem accessing file" + file.getAbsolutePath());
            }
        }
        game = false;
        drawing.setEntered(false);
        this.repaint();
    }//GEN-LAST:event_LoadFileActionPerformed

    private void SaveFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SaveFileActionPerformed
        if (maze != null) {
            int returnVal = placeChooser.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = placeChooser.getSelectedFile();
                try {
                    int count;
                    PrintWriter writer = new PrintWriter(file + ".txt");
                    writer.println(maze.numOfRows + " " + maze.numOfColumns);
                    for (int i = 0; i < maze.numOfRows; i++)
                        for (int j = 0; j < maze.numOfColumns; j++) {
                            Cell cell = maze.cells[i][j];
                            count = 0;
                            if (cell.canMoveTo(Direction.UP)) {
                                if (i != 0)
                                    if (!maze.cells[i-1][j].canMoveTo(Direction.DOWN)) {
                                        writer.print(i + "," + j + "," + 1);
                                        count++;
                                    }
                            }
                            if (cell.canMoveTo(Direction.RIGHT)) {
                                if (count == 0) {
                                    writer.print(i + "," + j + "," + 2);
                                    count++;
                                } else writer.print("," + 2);
                            }
                            if (cell.canMoveTo(Direction.DOWN)) {
                                if (count == 0) {
                                    writer.print(i + "," + j + "," + 3);
                                    count++;
                                } else writer.print("," + 3);
                            }
                            if (cell.canMoveTo(Direction.LEFT)) {
                                if (count == 0)
                                    if (j != 0)
                                        if (!maze.cells[i][j-1].canMoveTo(Direction.RIGHT)) {
                                            writer.print(i + "," + j + "," + 4);
                                            count++;
                                        }
                                if (count != 0)
                                    if (j != 0)
                                        if (!maze.cells[i][j-1].canMoveTo(Direction.RIGHT))
                                            writer.print("," + 4);
                            }
                            if (count != 0)
                                writer.println();
                        }
                    writer.close();
                } catch (IOException ex) {
                    System.out.println("Problem accessing file" + file.getAbsolutePath());
                }
            }
        } else {
            JOptionPane.showMessageDialog(this, "The maze is not created yet!", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_SaveFileActionPerformed

     class MyCustomFilter extends javax.swing.filechooser.FileFilter {
        @Override
        public boolean accept(File file) {
            // Allow only directories, or files with ".txt" extension
            return file.isDirectory() || file.getAbsolutePath().endsWith(".txt");
        }
        @Override
        public String getDescription() {
            // This description will be displayed in the dialog,
            // hard-coded = ugly, should be done via I18N
            return "Text documents (*.txt)";
        }
    } 
    /**
     * @param args the command line arguments
     */
     
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }

    public void setGame(boolean game) {
        this.game = game;
    }

    public void setResult(int result) {
        this.result = result;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem Color;
    private javax.swing.JMenuItem CreateMaze;
    private javax.swing.JMenuItem Dot;
    private javax.swing.JRadioButtonMenuItem Edit;
    private javax.swing.JMenu EditMode;
    private javax.swing.JMenuItem Exit;
    private javax.swing.JMenu Game;
    private javax.swing.JMenuItem LoadFile;
    private javax.swing.JRadioButtonMenuItem Play;
    private javax.swing.JMenuItem SaveFile;
    private javax.swing.JMenu Start;
    private javax.swing.JMenuItem TakeAChallenge;
    private javax.swing.ButtonGroup buttonGroup1;
    private view.Drawing drawing;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JMenuBar jMenuBar;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JFileChooser placeChooser;
    // End of variables declaration//GEN-END:variables
}
